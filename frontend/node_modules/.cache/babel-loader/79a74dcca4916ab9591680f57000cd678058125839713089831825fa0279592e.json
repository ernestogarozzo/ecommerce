{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nexports.default = financeDiscontinuousScale;\nvar _d3Collection = require(\"d3-collection\");\nvar _d3Array = require(\"d3-array\");\nvar _d3Scale = require(\"d3-scale\");\nvar _utils = require(\"../utils\");\nvar _levels = require(\"./levels\");\nvar MAX_LEVEL = _levels.levelDefinition.length - 1;\nfunction financeDiscontinuousScale(index, futureProvider) {\n  var backingLinearScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _d3Scale.scaleLinear)();\n  if ((0, _utils.isNotDefined)(index)) throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n  scale.invert = function (x) {\n    var inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n  scale.ticks = function (m, flexTicks) {\n    var backingTicks = backingLinearScale.ticks(m);\n    var ticksMap = (0, _d3Collection.map)();\n    var _backingLinearScale$d = backingLinearScale.domain(),\n      _backingLinearScale$d2 = _slicedToArray(_backingLinearScale$d, 2),\n      domainStart = _backingLinearScale$d2[0],\n      domainEnd = _backingLinearScale$d2[1];\n    var start = Math.max(Math.ceil(domainStart), (0, _utils.head)(index).index) + Math.abs((0, _utils.head)(index).index);\n    var end = Math.min(Math.floor(domainEnd), (0, _utils.last)(index).index) + Math.abs((0, _utils.head)(index).index);\n    if (Math.floor(domainEnd) > end) {\n      // console.log(end, domainEnd, index);\n    }\n    var desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n    for (var i = MAX_LEVEL; i >= 0; i--) {\n      var ticksAtLevel = ticksMap.get(i);\n      var temp = (0, _utils.isNotDefined)(ticksAtLevel) ? [] : ticksAtLevel.slice();\n      for (var j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n      ticksMap.set(i, temp);\n    }\n    var unsortedTicks = [];\n    for (var _i = MAX_LEVEL; _i >= 0; _i--) {\n      if (ticksMap.get(_i).length + unsortedTicks.length > desiredTickCount * 1.5) break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(_i).map(function (d) {\n        return d.index;\n      }));\n    }\n    var ticks = unsortedTicks.sort(_d3Array.ascending);\n\n    // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      var ticksSet = (0, _d3Collection.set)(ticks);\n      var d = Math.abs((0, _utils.head)(index).index);\n\n      // ignore ticks within this distance\n      var distance = Math.ceil((backingTicks.length > 0 ? ((0, _utils.last)(backingTicks) - (0, _utils.head)(backingTicks)) / backingTicks.length / 4 : 1) * 1.5);\n      for (var _i2 = 0; _i2 < ticks.length - 1; _i2++) {\n        for (var _j = _i2 + 1; _j < ticks.length; _j++) {\n          if (ticks[_j] - ticks[_i2] <= distance) {\n            ticksSet.remove(index[ticks[_i2] + d].level >= index[ticks[_j] + d].level ? ticks[_j] : ticks[_i2]);\n          }\n        }\n      }\n      var tickValues = ticksSet.values().map(function (d) {\n        return parseInt(d, 10);\n      });\n\n      // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n    return ticks;\n  };\n  scale.tickFormat = function () {\n    return function (x) {\n      var d = Math.abs((0, _utils.head)(index).index);\n      var _index$Math$floor = index[Math.floor(x + d)],\n        format = _index$Math$floor.format,\n        date = _index$Math$floor.date;\n      return format(date);\n    };\n  };\n  scale.value = function (x) {\n    var d = Math.abs((0, _utils.head)(index).index);\n    if ((0, _utils.isDefined)(index[Math.floor(x + d)])) {\n      var date = index[Math.floor(x + d)].date;\n      return date;\n    }\n  };\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n  scale.copy = function () {\n    return financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n  };\n  return scale;\n}","map":{"version":3,"names":["financeDiscontinuousScale","_d3Collection","require","_d3Array","_d3Scale","_utils","_levels","MAX_LEVEL","levelDefinition","length","index","futureProvider","backingLinearScale","arguments","undefined","scaleLinear","isNotDefined","Error","scale","x","invert","inverted","Math","round","domain","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","map","_backingLinearScale$d","_backingLinearScale$d2","_slicedToArray","domainStart","domainEnd","start","max","ceil","head","abs","end","min","floor","last","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","set","unsortedTicks","_i","concat","d","sort","ascending","ticksSet","distance","_i2","_j","remove","tickValues","values","parseInt","tickFormat","_index$Math$floor","format","date","value","isDefined","nice","copy"],"sources":["D:\\FUN\\Full-Stack\\ecommerce\\frontend\\node_modules\\src\\lib\\scale\\financeDiscontinuousScale.js"],"sourcesContent":["\n\nimport { set, map } from \"d3-collection\";\nimport { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\n\nimport { isDefined, isNotDefined, head, last } from \"../utils\";\nimport { levelDefinition } from \"./levels\";\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n\tindex,\n\tfutureProvider,\n\tbackingLinearScale = scaleLinear()\n) {\n\n\tif (isNotDefined(index))\n\t\tthrow new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n\n\tfunction scale(x) {\n\t\treturn backingLinearScale(x);\n\t}\n\tscale.invert = function(x) {\n\t\tconst inverted = backingLinearScale.invert(x);\n\t\treturn Math.round(inverted * 10000) / 10000;\n\t};\n\tscale.domain = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.domain();\n\t\tbackingLinearScale.domain(x);\n\t\treturn scale;\n\t};\n\tscale.range = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.range();\n\t\tbackingLinearScale.range(x);\n\t\treturn scale;\n\t};\n\tscale.rangeRound = function(x) {\n\t\treturn backingLinearScale.range(x);\n\t};\n\tscale.clamp = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.clamp();\n\t\tbackingLinearScale.clamp(x);\n\t\treturn scale;\n\t};\n\tscale.interpolate = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.interpolate();\n\t\tbackingLinearScale.interpolate(x);\n\t\treturn scale;\n\t};\n\tscale.ticks = function(m, flexTicks) {\n\t\tconst backingTicks = backingLinearScale.ticks(m);\n\t\tconst ticksMap = map();\n\n\t\tconst [domainStart, domainEnd] = backingLinearScale.domain();\n\n\t\tconst start = Math.max(Math.ceil(domainStart), head(index).index) + Math.abs(head(index).index);\n\t\tconst end = Math.min(Math.floor(domainEnd), last(index).index) + Math.abs(head(index).index);\n\n\t\tif (Math.floor(domainEnd) > end) {\n\t\t\t// console.log(end, domainEnd, index);\n\t\t}\n\n\t\tconst desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tconst ticksAtLevel = ticksMap.get(i);\n\t\t\tconst temp = isNotDefined(ticksAtLevel)\n\t\t\t\t? []\n\t\t\t\t: ticksAtLevel.slice();\n\n\t\t\tfor (let j = start; j <= end; j++) {\n\t\t\t\tif (index[j].level === i) {\n\t\t\t\t\ttemp.push(index[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tticksMap.set(i, temp);\n\t\t}\n\n\t\tlet unsortedTicks = [];\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tif ((ticksMap.get(i).length + unsortedTicks.length) > desiredTickCount * 1.5) break;\n\t\t\tunsortedTicks = unsortedTicks.concat(ticksMap.get(i).map(d => d.index));\n\t\t}\n\n\t\tconst ticks = unsortedTicks.sort(ascending);\n\n\t\t// console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n\t\tif (!flexTicks && end - start > ticks.length) {\n\t\t\tconst ticksSet = set(ticks);\n\n\t\t\tconst d = Math.abs(head(index).index);\n\n\t\t\t// ignore ticks within this distance\n\t\t\tconst distance = Math.ceil(\n\t\t\t\t(backingTicks.length > 0\n\t\t\t\t\t? (last(backingTicks) - head(backingTicks)) / (backingTicks.length) / 4\n\t\t\t\t\t: 1) * 1.5);\n\n\t\t\tfor (let i = 0; i < ticks.length - 1; i++) {\n\t\t\t\tfor (let j = i + 1; j < ticks.length; j++) {\n\t\t\t\t\tif (ticks[j] - ticks[i] <= distance) {\n\t\t\t\t\t\tticksSet.remove(index[ticks[i] + d].level >= index[ticks[j] + d].level ? ticks[j] : ticks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tickValues = ticksSet.values().map(d => parseInt(d, 10));\n\n\t\t\t// console.log(ticks.length, tickValues, level);\n\t\t\t// console.log(ticks, tickValues, distance);\n\n\t\t\treturn tickValues;\n\t\t}\n\n\t\treturn ticks;\n\t};\n\tscale.tickFormat = function() {\n\t\treturn function(x) {\n\t\t\tconst d = Math.abs(head(index).index);\n\t\t\tconst { format, date } = index[Math.floor(x + d)];\n\t\t\treturn format(date);\n\t\t};\n\t};\n\tscale.value = function(x) {\n\t\tconst d = Math.abs(head(index).index);\n\t\tif (isDefined(index[Math.floor(x + d)])) {\n\t\t\tconst { date } = index[Math.floor(x + d)];\n\t\t\treturn date;\n\t\t}\n\t};\n\tscale.nice = function(m) {\n\t\tbackingLinearScale.nice(m);\n\t\treturn scale;\n\t};\n\tscale.index = function(x) {\n\t\tif (!arguments.length) return index;\n\t\tindex = x;\n\t\treturn scale;\n\t};\n\tscale.copy = function() {\n\t\treturn financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n\t};\n\treturn scale;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}